#     else{
#       gbd_city_region_data_agg[[index]][[var_rate]] <- gbd_city_region_data_agg[[index]][[var_med]] /
#         gbd_city_region_data_agg[[index]]$population_number
#     }
#   }
# }
#
## Save as rds for each city region
write_rds(gbd_city_region_data_agg[[index]], paste0(relative_path_mslt, "data/city regions/GBD sorted/", unique(city_regions_list_loc[[i]][[1]]$cityregion), ".rds"))
index <- index + 1
}
## CREATE ONE DATA FRAME WITH ALL LIST IN GBD DATA FRAME AGGREGATED, THEN, THIS INFO IS NEEDED IN COMPILING ALL DATA FOR MSLT
gbd_data <- plyr::ldply(gbd_city_region_data_agg, rbind)
gbd_data$area <- gbd_data$.id
### Calculate rates as we need these for mslt data frame
### Calculate rates per one. Needed for mslt_code
for (d in 1:nrow(DISEASE_SHORT_NAMES)){
for (dm in 1:length(disease_measures_list)){
# dn <- DISEASE_SHORT_NAMES$disease[d]
dmeasure <- disease_measures_list[dm] %>% as.character() %>% tolower
var_rate <- c(paste(tolower(paste(dmeasure, "rate", DISEASE_SHORT_NAMES$sname[d], sep = "_"))))
var_med <- c(paste(tolower(paste(dmeasure, "med", DISEASE_SHORT_NAMES$sname[d], sep = "_"))))
if ((var_rate == "deaths_rate_mjdd" || var_rate == "ylds (years lived with disability)_rate_mjdd")){
}
else{
gbd_data[[var_rate]] <- gbd_data[[var_med]] /
gbd_data$population_number
}
}
}
load("C:/Metahit/mh-mslt/data/city regions/Output disbayes/cityregions_smoothed_res.rda")
# ---- chunk-Introduction: Disbayes data generation generation ----
## The below code generates data to use as inputs in disbayes.
## To run this code, first the following data preparation (from dataprep.R scrip has to be generated)
## 1) gbd_city_region_data
## 2) disease_measure list
## 3) DISEASE_SHORT_NAMES
# ---- chunk-1: Disbayes input generation ----
# ---- chunk-1.2: Generate city regions dataframes in a list ----
index <- 1
disbayes_input_list_city_regions <- list()
for (i in 1:length(gbd_city_region_data_agg)) {
disbayes_input_list_city_regions[[index]] <- GenInpDisbayes(gbd_city_region_data_agg[[i]])
# disbayes_input_list_city_regions[[index]]$cityregion <- paste(names(gbd_city_region_data_agg[i]))
# # disbayes_input_list_city_regions[[index]]$cityregion<- paste0(names(gbd_city_region_data_agg[i]))
names(disbayes_input_list_city_regions)[index] <- paste0(names(gbd_city_region_data_agg[i]))
index <- index + 1
}
# ---- chunk-1.2.1: Add city regions names ----
for (i in 1:length(disbayes_input_list_city_regions)){
for (j in 1:length(disbayes_input_list_city_regions[[i]])) {
disbayes_input_list_city_regions[[i]][[j]]$cityregion <- paste(names(disbayes_input_list_city_regions[i]))
}
}
# ---- chunk-1.2.2: Generate num and denom using ci2num for incidence, prevalence and mortlaity ----
disbayes_input_list_city_regions_2 <- list()
index <- 1
for (i in 1:length(gbd_city_region_data)) {
for (dm in 1:length(disease_measures_list)){
for (d in 1:nrow(DISEASE_SHORT_NAMES)){
in_measure <- disease_measures_list[dm] %>% as.character() %>% tolower()
### exclude ylds for now, we are interested in disbayes inputs but later may use ylds uncertainty parameters
if (DISEASE_SHORT_NAMES$is_not_dis[d] != 0 || in_measure == "ylds (years lived with disability)" ||
DISEASE_SHORT_NAMES$disease[d] == "hypertensive heart disease" ||
DISEASE_SHORT_NAMES$disease[d] == "major depressive disorder")
{
}
else {
med <- paste0(in_measure, "_med_", DISEASE_SHORT_NAMES$sname[d])
low <- paste0(in_measure, "_lower95_", DISEASE_SHORT_NAMES$sname[d])
upper <- paste0(in_measure, "_upper95_", DISEASE_SHORT_NAMES$sname[d])
## These data is in 5-year age groups.
data <- gbd_city_region_data[[i]]
disbayes_input_list_city_regions_2[[index]] <- dplyr::select(data, population_number, cityregion, location, sex_age_cat, med, low, upper)
disbayes_input_list_city_regions_2[[index]]$est <- disbayes_input_list_city_regions_2[[index]][[med]]/disbayes_input_list_city_regions_2[[index]][[1]]
disbayes_input_list_city_regions_2[[index]]$lower <- disbayes_input_list_city_regions_2[[index]][[low]]/disbayes_input_list_city_regions_2[[index]][[1]]
disbayes_input_list_city_regions_2[[index]]$upper <- disbayes_input_list_city_regions_2[[index]][[upper]]/disbayes_input_list_city_regions_2[[index]][[1]]
disbayes_input_list_city_regions_2[[index]]$index <- paste(in_measure, DISEASE_SHORT_NAMES$sname[d], sep = "_")
disbayes_input_list_city_regions_2[[index]]$indexagg <- paste(disbayes_input_list_city_regions_2[[index]]$index, disbayes_input_list_city_regions_2[[index]]$sex_age_cat,
disbayes_input_list_city_regions_2[[index]]$cityregion, sep = "_")
## Separate age and sex and
suppressWarnings(names(disbayes_input_list_city_regions_2)[index] <- paste(gbd_city_region_data[[i]]$cityregion,in_measure, DISEASE_SHORT_NAMES$sname[d], sep = '_'))
index <- index + 1
}
}
}
}
# ---- chunk-1.2.4: Generate num and denoms using Ci2NumDF ----
## trycatch is used to avoid issues with prevalence when runnind Ci2NumDF
tryCatchCi2NumDF <- function(x) tryCatch(Ci2NumDF(x), error = function(e) e)
disbayes_input_list_city_regions_3  <- lapply(disbayes_input_list_city_regions_2, tryCatchCi2NumDF)
# ---- chunk-1.2.5: Create a dataframe with all city regions data ----
## This step is to delete the data frames with errors from the list before appending the data frames in the list in a unique dataframe.
has_prevc <- c(grepl("prevalence",names(disbayes_input_list_city_regions_3)) == TRUE) %>% as.character()
index <- 1
disbayes_input_list_city_regions_3b <- list()
for (i in 1:length(disbayes_input_list_city_regions_3)) {
if(has_prevc[[index]] == "TRUE" ) {}
else{
disbayes_input_list_city_regions_3b[[index]] <- disbayes_input_list_city_regions_3[[i]]
}
index <- index + 1
}
disbayes_input_list_city_regions_3b <-  list.clean(disbayes_input_list_city_regions_3b, fun = is.null, recursive = TRUE)
disbayes_input_list_city_regions_4 <- disbayes_input_list_city_regions_3b %>% lapply(as.data.frame) %>% bind_rows() %>% group_by(indexagg)
### Old, does not work, replaced by code above
# disbayes_input_list_city_regions_4 <- dplyr::ldply(disbayes_input_list_city_regions_3b, rbind) %>% group_by(indexagg)
disbayes_input_list_city_regions_5 <- disbayes_input_list_city_regions_4 %>% summarise_all(funs(sum))
disbayes_input_list_city_regions_5$indexagg <- gsub("'", '', disbayes_input_list_city_regions_5$indexagg)
disbayes_input_list_city_regions_6 <- disbayes_input_list_city_regions_5 %>%  mutate_if(is.character, RemoveAllWs)%>%
mutate(index = indexagg) %>%
separate(indexagg, c("measure", "disease", "sex", "age", "cityregion"))
## Add new variable with mid-age group
disbayes_input_list_city_regions_6$agegr <- 0
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="Under5"] <- 0
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="5to9"] <- 5
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="10to14"] <- 10
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="15to19"] <- 15
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="20to24"] <- 20
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="25to29"] <- 25
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="30to34"] <- 30
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="35to39"] <- 35
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="40to44"] <- 40
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="45to49"] <- 45
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="50to54"] <- 50
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="55to59"] <- 55
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="60to64"] <- 60
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="65to69"] <- 65
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="70to74"] <- 70
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="75to79"] <- 75
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="80to84"] <- 80
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="85to89"] <- 85
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="90to94"] <- 90
disbayes_input_list_city_regions_6$agegr [ disbayes_input_list_city_regions_6$age =="95plus"] <- 95
city_regions_names <- unique(disbayes_input_list_city_regions_6$cityregion)
disease_disbayes <- unique(disbayes_input_list_city_regions_6$disease)
measure_disbayes <- unique(disbayes_input_list_city_regions_6$measure)
sex_disbayes <- unique(disbayes_input_list_city_regions_6$sex)
## To wider
disbayes_input_list_city_regions_7 <- disbayes_input_list_city_regions_6 %>%
pivot_wider(id_cols = c(agegr, sex, population_number, cityregion, measure, disease),
names_from = measure, values_from = c(num, denom))
## Create list
index <- 1
disbayes_input_list2 <- list()
for (c in city_regions_names){
for (d in disease_disbayes){
for (s in sex_disbayes){
disbayes_input_list2[[index]] <- dplyr::filter(disbayes_input_list_city_regions_7, cityregion == c, disease == d, sex == s)
disbayes_input_list2[[index]] <- disbayes_input_list2[[index]][order(disbayes_input_list2[[index]]$agegr),]
outage <- 0:100  # assume num and denom are the same in each year within a five-year age group
#
ind <- findInterval(outage, disbayes_input_list2[[index]]$agegr)
disbayes_input_list2[[index]] <- disbayes_input_list2[[index]][ind,]
disbayes_input_list2[[index]]$age <- outage
### It leaves NA values (I need to have all columns filled in)
disbayes_input_list2[[index]]$index <- tolower(paste(disbayes_input_list2[[index]]$sex,
disbayes_input_list2[[index]]$disease,
disbayes_input_list2[[index]]$age,
disbayes_input_list2[[index]]$cityregion, sep = "_"))
# disbayes_input_list2[[index]] <- disbayes_input_list2[[index]] %>% pivot_wider(id_cols = c(index), names_from = measure, values_from = c(num, denom))
index <- index + 1
}
}
}
# ---- chunk-1.2.6: Join dataframes with all disbayes inputs ----
## First data set rates
disbayes_inputs_df <- do.call(rbind, disbayes_input_list_city_regions)
### Some issue with disease column, which we do not need, to rbind to dataframe
disbayes_inputs_df <- lapply(disbayes_inputs_df, function(x) { x["disease"] <- NULL; x })
disbayes_inputs_df <- dplyr::bind_rows(disbayes_inputs_df)
### CHECK WHAT HAPPENEND WITH CITY REGIONS AND THATN INDEX IS THE SAME AS IN DISBAYES INPUT DATAFRAME2
disbayes_inputs_df$index <- paste(disbayes_inputs_df$sex_disease, disbayes_inputs_df$age, disbayes_inputs_df$cityregion, sep = "_")
## Second data set with num and denom
disbayes_inputs_df2 <- do.call(rbind, disbayes_input_list2)
disbayes_inputs_df2 <-   disbayes_inputs_df2[ -c(1:5,10) ]
## Final data set to process in disbayes. Filter data by city region, disease and sex. COMPARE with saved data in rds
disbayes_inputs <- disbayes_inputs_df %>%
left_join(disbayes_inputs_df2) %>%
separate(sex_disease, c("drop", "disease"))
disbayes_inputs <- disbayes_inputs[, !(colnames(disbayes_inputs ) %in% c("drop","index"))]
write_rds(disbayes_inputs, paste0(relative_path_mslt, "data/city regions/Input disbayes/disbayes_inputs", ".rds"))
index <- 1
disbayes_input_list_city_regions <- list()
for (i in 1:length(gbd_city_region_data_agg)) {
disbayes_input_list_city_regions[[index]] <- GenInpDisbayes(gbd_city_region_data_agg[[i]])
# disbayes_input_list_city_regions[[index]]$cityregion <- paste(names(gbd_city_region_data_agg[i]))
# # disbayes_input_list_city_regions[[index]]$cityregion<- paste0(names(gbd_city_region_data_agg[i]))
names(disbayes_input_list_city_regions)[index] <- paste0(names(gbd_city_region_data_agg[i]))
index <- index + 1
}
source('code/functions.R')
## Data
## move name changes here
relative_path <- '../mh-mslt/'
pif_expanded <- read_csv(paste0(relative_path, 'data/pif_expanded.csv'))
# Check
DISEASE_SHORT_NAMES <<- read_csv(paste0(relative_path, 'data/parameters/disease_names.csv'))
## Parameters
year <- 2017
# year_trend <- 2007 (not used for now)
i_age_cohort <- c(17, 22, 27, 32, 37, 42, 47, 52, 57, 62, 67, 72, 77, 82, 87, 92, 97)
i_sex <- c('male', 'female')
# ---- chunk-1.5: Create data frame for city region with all localities ----
index <- 1
gbd_city_region_data <- list()
for (i in 1:length(gbd_loc_data_processed)){
gbd_city_region_data[[index]] <- bind_rows(gbd_loc_data_processed[[i]])
## Drop number columns (CHECK WHAT THIS IS DOING)
#
#    gbd_city_region_data[[index]] <- gbd_city_region_data[[index]][ -c(1) ]
## Clean dataframes per city regions
gbd_city_region_data[[index]] <- dplyr::select(gbd_city_region_data[[index]], -contains('rate')) %>% mutate_if(is.factor, as.character)
gbd_city_region_data[[index]]$sex_age_cat <- paste(gbd_city_region_data[[index]]$sex, gbd_city_region_data[[index]]$age, sep = "_")
gbd_city_region_data[[index]] <- select(gbd_city_region_data[[index]], -c(age, sex))
### Add city region name here
suppressWarnings(names(gbd_city_region_data)[index] <- paste(city_regions_list_loc[[i]][[1]]$cityregion, sep = '_'))
gbd_city_region_data[[index]]$cityregion <- names(gbd_city_region_data)[index]
index <- index + 1
}
## Create aggregated data frame (sums all numbers from localities within a city region) SEE HOW THIS IS WORKING, best to continue
### with dataframe above and then have a combined dataset with all possible inputs for disbayes
#### Drop location and city region (sum cannot summ string variables)
### Rename gbd_city_region_data, as cityregionand location variables are needed in disbayes data_prep
#
gbd_city_region_data_2 <- list()
for (i in 1:length(gbd_city_region_data)) {
gbd_city_region_data_2[[i]] <- gbd_city_region_data[[i]]
#[ -c(1,3) ]
}
gbd_city_region_data_agg <- list()
index <- 1
### Loop to generate aggregated data
for (i in 1:length(gbd_city_region_data_2)) {
gbd_city_region_data_agg[[index]] <- gbd_city_region_data_2[[i]] %>%
group_by(sex_age_cat) %>%
summarise_all(funs(if(is.numeric(.)) sum(., na.rm = TRUE) else first(.)))%>%
separate(sex_age_cat, c("sex", "age"), "_")
## Add numberical age categories
gbd_city_region_data_agg[[index]]$age_cat <- 0
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="Under 5"] <- 2
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="5 to 9"] <- 7
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="10 to 14"] <- 12
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="15 to 19"] <- 17
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="20 to 24"] <- 22
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="25 to 29"] <- 27
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="30 to 34"] <- 32
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="35 to 39"] <- 37
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="40 to 44"] <- 42
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="45 to 49"] <- 47
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="50 to 54"] <- 52
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="55 to 59"] <- 57
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="60 to 64"] <- 62
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="65 to 69"] <- 67
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="70 to 74"] <- 72
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="75 to 79"] <- 77
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="80 to 84"] <- 82
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="85 to 89"] <- 87
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="90 to 94"] <- 92
gbd_city_region_data_agg[[index]]$age_cat [ gbd_city_region_data_agg[[index]]$age =="95 plus"] <- 97
## Change sex variable to lower case
gbd_city_region_data_agg[[index]]$sex <- tolower(gbd_city_region_data_agg[[index]]$sex)
## Create age_sex category
gbd_city_region_data_agg[[index]]$sex_age_cat <- paste(gbd_city_region_data_agg[[index]]$sex,gbd_city_region_data_agg[[index]]$age_cat, sep = "_"  )
## Order data
gbd_city_region_data_agg[[index]] <- gbd_city_region_data_agg[[index]][order(gbd_city_region_data_agg[[index]]$sex, gbd_city_region_data_agg[[index]]$age_cat),]
suppressWarnings(names(gbd_city_region_data_agg)[index] <- paste(city_regions_list_loc[[i]][[1]]$cityregion, sep = '_'))
### Calculate rates per one. Needed for mslt_code
# for (d in 1:nrow(DISEASE_SHORT_NAMES)){
#   for (dm in 1:length(disease_measures_list)){
#     # dn <- DISEASE_SHORT_NAMES$disease[d]
#     dmeasure <- disease_measures_list[dm] %>% as.character() %>% tolower
#
#
#
#     var_rate <- c(paste(tolower(paste(dmeasure, "rate", DISEASE_SHORT_NAMES$sname[d], sep = "_"))))
#     var_med <- c(paste(tolower(paste(dmeasure, "med", DISEASE_SHORT_NAMES$sname[d], sep = "_"))))
#
#
#     if ((var_rate == "deaths_rate_mjdd" || var_rate == "ylds (years lived with disability)_rate_mjdd")){
#     }
#     else{
#       gbd_city_region_data_agg[[index]][[var_rate]] <- gbd_city_region_data_agg[[index]][[var_med]] /
#         gbd_city_region_data_agg[[index]]$population_number
#     }
#   }
# }
#
## Save as rds for each city region
write_rds(gbd_city_region_data_agg[[index]], paste0(relative_path_mslt, "data/city regions/GBD sorted/", unique(city_regions_list_loc[[i]][[1]]$cityregion), ".rds"))
index <- index + 1
}
## CREATE ONE DATA FRAME WITH ALL LIST IN GBD DATA FRAME AGGREGATED, THEN, THIS INFO IS NEEDED IN COMPILING ALL DATA FOR MSLT
gbd_data <- plyr::ldply(gbd_city_region_data_agg, rbind)
gbd_data$area <- gbd_data$.id
### Calculate rates as we need these for mslt data frame
### Calculate rates per one. Needed for mslt_code
for (d in 1:nrow(DISEASE_SHORT_NAMES)){
for (dm in 1:length(disease_measures_list)){
# dn <- DISEASE_SHORT_NAMES$disease[d]
dmeasure <- disease_measures_list[dm] %>% as.character() %>% tolower
var_rate <- c(paste(tolower(paste(dmeasure, "rate", DISEASE_SHORT_NAMES$sname[d], sep = "_"))))
var_med <- c(paste(tolower(paste(dmeasure, "med", DISEASE_SHORT_NAMES$sname[d], sep = "_"))))
if ((var_rate == "deaths_rate_mjdd" || var_rate == "ylds (years lived with disability)_rate_mjdd")){
}
else{
gbd_data[[var_rate]] <- gbd_data[[var_med]] /
gbd_data$population_number
}
}
}
warnings()
View(gbd_loc_data_processed)
## Create R Markdown for data preparation
# ---- chunk-intro ----
## City regions, prepare a dataset for each of them by aggregating local goverment areas
# Sheffield City Region Combined Authority: Barnsley, Doncaster, Rotherham, Sheffield.
#
# North East Combined Authority: County Durham, Gateshead, Newcastle upon Tyne, North Tyneside, Northumberland, South Tyneside, Sunderland.
#
# Greater Manchester Combined Authority: Bolton, Bury, Manchester, Oldham, Rochdale, Salford, Stockport, Tameside, Trafford, Wigan.
#
# Liverpool City Region Combined Authority: Halton, Knowsley, Liverpool, St. Helens, Sefton, Wirral.
#
# West Yorkshire Combined Authority: Bradford, Calderdale, Kirklees, Leeds, Wakefield.
#
# Bristol: Bath and North East Somerset, City of Bristol, North Somerset, South Gloucestershire.
#
# Nottingham: Ashfield, Bassetlaw, Broxtowe, Gedling, Mansfield, Nottingham, Newark and Sherwood, Rushcliffe. (NO GBD DATA AVAILABLE)
#
# West Midlands Combined Authority: Birmingham, Coventry, Dudley, Sandwell, Solihull, Walsall, Wolverhampton.
require(readr)
require(rlist)
require(dplyr)
require(tidyverse)
source('code/functions.R')
# ---- chunk-1: Data preparation ----
## Run mslt_code lines to get requiered packages
## Relative paths
relative_path_execute <- '../mh-execute/'
relative_path_mslt <- '../mh-mslt/'
## Get look up table from mh-execute
look_up_table <- read_csv(paste0(relative_path_execute, 'inputs/mh_regions_lad_lookup.csv'))
## Dataframe with local goverment areas within each city region
local_goverment_areas <- look_up_table
## Add non city regions names (useful for checking totals)
names_non_cr <- c("United Kingdom", "England", "East Midlands", "East of England", "Greater London", "North East England",
'North West England', "South East England", "South West England", "West Midlands", "Yorkshire and the Humber",
"Northern Ireland", "Scotland", "Wales")
for (i in names_non_cr){
local_goverment_areas <- rbind(local_goverment_areas, c(i, i, i, i, i))
}
local_goverment_areas <-  local_goverment_areas %>% dplyr::filter(cityregion != "")
names(local_goverment_areas)[names(local_goverment_areas) == "lad11nm"] <- "location"
local_goverment_areas$location <- gsub('St. Helens', 'St Helens', local_goverment_areas$location)
city_regions <- split(local_goverment_areas$location, f = local_goverment_areas$cityregion)
# ---- chunk-1.1: Get Global Burden of Disease data ----
## GBD MISSING DATA FOR NOTTINGHAM: Ashfield, Bassetlaw, Broxtowe, Gedling, Mansfield, Newark and Sherwood, Rushcliffe and City of London.
## Get data from GBD dowloaded data for UK (all localities)
## Use code developed by Marko Tainio to extract zip files
## Created in February-March 2019 by Marko Tainio (modified by Belen Zapata June 2019 for Metahit project)
## This script extracts required Global Burden of Disease data from the zip files dowloaded from http://ghdx.healthdata.org/gbd-results-tool
## by first extracting zip-files, then reading csv file, adding required data to combined dataframe
## and finally deleiting extracted files. Resulting dataframe is then saved as csv-file.
## Defining folder where the data is stored (stored externally in my dropbox as the GBD files are large)
## CHANGE TO v-DRIVE
work_folder <- "C:/Users/e95517/"
home_folder <- "C:/Users/Bele/"
v_folder <- "V:/Studies/MOVED/HealthImpact/Data/Global_Burden_Disease_Metahit/"
## Change folder to work or home
# CHANGE DATA FOLDER
data_folder <- paste0(home_folder, "Dropbox/Collaborations/James Woodcock/Metahit/Data/GBD2017/")
temp_folder <- paste0(data_folder,"temp")
result_folder <- paste0(data_folder,"final")
gbdfile_name_new <- "IHME-GBD_2017_DATA-3e0b192d-" # CHANGE NAME WHEN NEW DATA IS DOWNLOADED
gbdfile_name_old <- "IHME-GBD_2017_DATA-ac95a757-" # CHANGE NAME WHEN NEW DATA IS DOWNLOADED
### New data: "C:\Users\e95517\Dropbox\Collaborations\James Woodcock\Metahit\Data\GBD2017\IHME-GBD_2017_DATA-3e0b192d-1.zip"
### Old data: "C:\Users\e95517\Dropbox\Collaborations\James Woodcock\Metahit\Data\GBD2017\IHME-GBD_2017_DATA-ac95a757-1.zip"
## Loop to extract zip file data for data with all diseases
##### All diseases in new meta analysis
data_extracted_new <- NULL
for (i in 1:5) { # LOOP NUMBER DEPENDS ON NUMBER OF ZIP FILES, HERE I JUST GOT DATA FOR ALL LOCALITIES IN ENGLAND
file_number <- i
file_select <- paste0(data_folder,gbdfile_name_new, i,".zip")
unzip(file_select, exdir=temp_folder)
data_read <- read_csv((paste0(temp_folder,"/", gbdfile_name_new, i, ".csv")))
file.remove(paste0(temp_folder,"/", gbdfile_name_new, i, ".csv"))
data_read <- subset(data_read, location_name %in% local_goverment_areas$location) # location name is easier to identify
data_extracted_new <- rbind(data_extracted_new,data_read)
}
unlink(paste0(temp_folder), recursive = TRUE)
##### Old diseases
data_extracted <- data_extracted_new
# ---- chunk-1.2: Define parameters from data ----
## Define measure (e.g. deaths) and cause parameters (e.g. all causes, breast cancer) (this is to avoid hard coding the parameters)
## Min Length is not changing anything, how can we make it characters in the first place, rather than having to ocnvert below before running RunLocDF?
DISEASE_SHORT_NAMES <- data.frame(disease = tolower(as.character(unique(data_extracted$cause_name))),
sname = tolower(abbreviate(unique(data_extracted$cause_name, max = 2))),
stringsAsFactors = F)
DISEASE_SHORT_NAMES <- DISEASE_SHORT_NAMES %>% mutate(is_not_dis = ifelse((str_detect(disease, "injuries") |
str_detect(disease, "All causes") |
str_detect(disease, "Lower respiratory infections")),
1, 0) )
DISEASE_SHORT_NAMES[DISEASE_SHORT_NAMES$sname == "allc", "is_not_dis"] <- 2
DISEASE_SHORT_NAMES[DISEASE_SHORT_NAMES$sname == "lwri", "is_not_dis"] <- 1
### Combine with acronyms from execute-mh
## Get execute-mh diseases
disease_names_execute <- read_csv(paste0(relative_path_execute, "inputs/dose_response/disease_outcomes_lookup.csv"))
disease_names_execute <- disease_names_execute[1:2]
disease_names_execute$disease <- tolower(disease_names_execute$GBD_name)
DISEASE_SHORT_NAMES <- left_join(DISEASE_SHORT_NAMES, disease_names_execute, by = "disease")
## Add injuries
DISEASE_SHORT_NAMES$acronym <- ifelse(str_detect(DISEASE_SHORT_NAMES$disease, "injuries"), DISEASE_SHORT_NAMES$disease, DISEASE_SHORT_NAMES$acronym)
## Only keep first word for acronyns
DISEASE_SHORT_NAMES$acronym <- word(DISEASE_SHORT_NAMES$acronym, 1)
## Add males and females only diseases
DISEASE_SHORT_NAMES$males <- ifelse(DISEASE_SHORT_NAMES$disease %in% c("breast cancer", "uterine cancer"), 0, 1)
DISEASE_SHORT_NAMES$females <- 1
DISEASE_SHORT_NAMES$sname <- gsub("'", '', DISEASE_SHORT_NAMES$sname)
## Replace NAs with blank
DISEASE_SHORT_NAMES$acronym[is.na(DISEASE_SHORT_NAMES$acronym)] <- "no_pif"
## Add column to match names from mh-execute
write_csv(DISEASE_SHORT_NAMES, "data/parameters/disease_names.csv")
disease_measures_list <- data.frame(measure = unique(data_extracted$measure_name)) %>%
pull(measure) %>%
as.character() %>%
as.list()
# ---- chunk-1.3: Clean data ----
names(data_extracted) = gsub(pattern = "_name", replacement = "", x = names(data_extracted))
data_extracted <- select(data_extracted,-contains("id"))
data_extracted$cause <- tolower(data_extracted$cause)
data_extracted <- left_join(local_goverment_areas, data_extracted, by = "location")
# ---- chunk-1.4: Sort data per local goverment area ----
## We first derive population and cases numbers (e.g. all cause mortality) for each locality and then aggregate at the City Region level.
city_regions_list_loc <- split(data_extracted , f = data_extracted$cityregion)
city_regions_list <- split(data_extracted , f = data_extracted$cityregion)
city_regions_list_loc <- list()
for (i in 1:length(city_regions_list)){
city_regions_list_loc[[i]] <- split(city_regions_list[[i]], f = city_regions_list[[i]]$location)
}
### This code takes about 0.5 hour to run CHECK WITH ROB AND ALAN HOW TO MAKE FASTER
index <- 1
gbd_loc_data_processed <- list()
for (i in 1:length(city_regions_list_loc)) {
gbd_loc_data_processed[[index]] <- lapply(city_regions_list_loc[[i]], RunLocDf)
index <- index + 1
}
### Delete null data frames within lists
gbd_loc_data_processed <-  list.clean(gbd_loc_data_processed, fun = is.null, recursive = TRUE)
bristol_bristol <- readRDS("C:/Metahit/mh-mslt/data/city regions/Input disbayes/bristol_bristol.rds")
View(bristol_bristol)
disbayes_inputs_original <- readRDS("C:/Metahit/mh-mslt/data/city regions/Input disbayes/disbayes_inputs_original.rds")
dat2 <- dplyr::filter(disbayes_inputs_original, cityregion == "greatermanchester", disease == "brsc", sex == "female")
library(disbayes)
resu <- disbayes(dat = dat,
## You can supply either estimates and denominators, or estimates with credible intervals, or numerators and denominators.  See help(disbayes)
# inc = "inc",
# inc_num = "num_incidence",
# inc_denom = "denom_incidence",
# prev_num = "prevn",
# prev_denom = "prevdenom",
# mort_num = "num_deaths",
# mort_denom = "num_deaths",
## Original data
inc = "inc",
inc_denom = "pop",
prev_num = "prevn",
prev_denom = "prevdenom",
mort = "mort",
mort_denom = "pop",
## You'll need to change this for different diseases:
## the age below which all case fatalities are
## assumed equal in the smoothed model
eqage = 30,
smooth = TRUE  # or FALSE if don't want smoothed estimates
)
## Posterior medians and 95% credible intervals for all unknowns in the model
summ <- summary(resu)
## Handy tool to extract specific variables from this
test_output <- as.data.frame(summary(resu, vars=c("cf","inc")))
## Plot smoothed and unsmoothed estimates
plot(resu)
resu <- disbayes(dat = dat2,
## You can supply either estimates and denominators, or estimates with credible intervals, or numerators and denominators.  See help(disbayes)
# inc = "inc",
# inc_num = "num_incidence",
# inc_denom = "denom_incidence",
# prev_num = "prevn",
# prev_denom = "prevdenom",
# mort_num = "num_deaths",
# mort_denom = "num_deaths",
## Original data
inc = "inc",
inc_denom = "pop",
prev_num = "prevn",
prev_denom = "prevdenom",
mort = "mort",
mort_denom = "pop",
## You'll need to change this for different diseases:
## the age below which all case fatalities are
## assumed equal in the smoothed model
eqage = 30,
smooth = TRUE  # or FALSE if don't want smoothed estimates
)
## Posterior medians and 95% credible intervals for all unknowns in the model
summ <- summary(resu)
## Handy tool to extract specific variables from this
test_output <- as.data.frame(summary(resu, vars=c("cf","inc")))
## Plot smoothed and unsmoothed estimates
plot(resu)
disbayes_inputs <- readRDS("C:/Metahit/mh-mslt/data/city regions/Input disbayes/disbayes_inputs.rds")
View(disbayes_inputs)
